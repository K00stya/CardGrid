Проблемой использования ООП в разработке является ложная инкапсуляция состояния и большая рассредоточенность полезного кода по отдельным классам.

1.Ложная инкапсуляция.

Если геймплей предполагает, что кнопка должна вызвать прыжок, то факт заключается в том, что кнопка прямо или косвенно вызовет метод прыжка в объекте персонажа. Даже если мы проводим этот вызов через интерфейс, абстракцию или подписанием метода персонажа на событие кнопки в специальной фабрике. Факт остается фактом - объект кнопки влияет на состояние объекта персонажа.
Если объектам необходимо взаимодействовать между собой и менять состояние друг друга означает что инкапсуляция между такими объектами невозможна, а их состояние является общим. (Объект ни с кем не взаимодействующий бесполезен).

2.Общее состояние.

Чтобы запрограммировать игру нам необходимо определить данные и методы которые их изменяют.
Например, у персонажа игрока есть здоровье, скорость и тд. на первый взгляд кажется что эти данные являются отдельным состоянием персонажа которые вправе изменять только он сам. Однако его состояние могут изменять другие объекты: инпут игрока, коллизии, способности, урон от других персонажей, состояние уровня, общий прогресс и пр. Мы делим состояние на отдельные объекты, но они по прежнему представляют одну систему.
Понимание одного отдельного объекта, ввиду его небольшой величины упрощается, в то время как понимание всей системы усложняется.

3.Усложнение.

ООП предполагает инкапсуляцию отдельных состояний, однако из-за того что объектам необходимо изменять состояния друг друга разделение общего состояния на объектам приводит усложнению системы.

К примеру в нашей игре есть кнопка, нажатие на которую должно вызывать прыжок персонажа. 

![chrome_OEgNQZNbOr](https://user-images.githubusercontent.com/86427892/174994000-b2a9a764-68dc-42b0-baf5-ae9b0c51fd12.png)

Мы не всегда можем изначально указать ссылку на персонажа из-за того что кнопка и персонаж принадлежат разным композициям. Соответственно время их жизни различно. Может быть загружен другой уровень, другой персонаж или вместо игрового интерфейса с нужной нам кнопкой открыто главное меню.

Чтобы объекты получили возможность взаимодействовать между собой их необходимо использовать в рамках общей композиции, которая определяет время жизни и применения объектов.
Однако мысля в рамках ООП мы должны разделять ответственность по объектам, поэтому мы не доверяем кнопке прямое влияние на персонажа (хотя оно есть), классу интерфейса игрока тоже, а передаем событие нажатия соответствующей композиции уровня, которая уже достаточно уполномочена для этого.

![chrome_xb0PDAQm09](https://user-images.githubusercontent.com/86427892/174994155-15de4f6f-3b39-4d5e-a766-8c00719f4830.png)

Получается хоть и объектно ориентированная, но усложненная схема. На первый взгляд разделив ответственность по объектам мы упростили работу себе и другим программистам. То за что ответственна только кнопка - происходит только в коде кнопки, то за что ответственен персонаж происходит только в его коде.
Давайте пойдем дальше в разработке нашей игры и добавим сопутствующие операции и паттерны, которые часто встречаются разработке в игр.

Вот самый безобидный вариант.

![chrome_FM67A3k8Sc](https://user-images.githubusercontent.com/86427892/175002382-695bff66-28f6-48fd-a6e9-b5726d21841f.png)

Событие нажатия нашей кнопки передается в ответственную за кнопку композицию PlayerUI, однако нажатие кнопок может вызывать события связанные с UI, но согласно ООП ему не под ответственные, например сбор аналитики, инпута игрока для статистики или античита, активация рекламы, вторичных анимаций и пр. для этого функционала мы создаем дополнительный класс PlayerUIDecorator. Декоратор уровня создан по той же причине. Иногда декораторов для одного объекта может быть несколько, так что на этой схеме все еще не так плохо.
Создание экземпляра персонажа часто требует большого количества операций, да и персонажи могут быть разные поэтому используется отдельный класс CharacterFactory, который возвращает готового персонажа с установленными зависимостями.
Главная композиция устанавливает связь между UI и Level, передавая ссылку события нажатия кнопки на игровом интерфейсе в уровень который с помощью фабрики подпишет метод Jump на OnClick.

Даже без использования наследования, абстракций и интерфейсов количество этапов через которые проходит событие нажатия кнопки прыжка сложно воспринимать. На схеме изображена работа только одной кнопки, когда мы добавим все возможные источники изменения состояния персонажа вместо понятной схемы перед нами будет паутина, если к схеме добавим остальные объекты, их источники изменений, потом добавим на кого могут влиять сами объекты получится каша из стрелок едва ли представляющая какую-то ценность.

ООП распределяет ответственность между классами, что делает пониманием отдельно взятого касса простым, но усложняет понимание всей системы. К тому же инкапсуляция оказывается мнимой: состояние персонажа изменяется не только из композиции уровня, но и косвенно из любой части игры.

4.Философия вместо написания кода.

Для внесения изменения и тем более для полноценной разработки приходится знать всю систему. Для полного понимания объекта в ООП недостаточно знать только сам объект. Необходимо знать кто и когда может влиять на его состояние. Более того, необходимо знать на кого влияет он сам и объекты которые являются частью его состояния по принципу композиции или ассоциации. Не зная контекста определить нарушаете вы своими изменениями принцип единой ответственности или принцип Лисков невозможно. 

Названия классов и методов хоть и могут дать немало информации, но также являются относительными. Если вы увидите класс Window с публичными методами Open, Close всем в голову приду разные мысли, это может быть как один из скриптов UI так и полноценный игровой объект. Прочтение кода отдельного касса совсем не гарантирует его полное понимание, потому что это код может использоваться совершенно непредсказуемым образом в других объектах.
Когда в игру необходимо добавить новую функцию которая изменяет более одного состояния первое о чем нужно задуматься ООП программисту - чей это метод?

Есть классический пример с пулей попадающей в противника, кто должен принимать событие попадания и отнимать здоровье сам противник или пуля? Обычно если все пули могут наносить только урон, то ответ прост - тот в кого попали изменяет своё состояние здоровья. А если есть множество вариантов пуль с разными эффектами, тогда функционал мигрирует в классы пуль, которые сами решают как воздействовать на жертву и сообщают ей результат. А если наоборот, пули стали одинаковыми, а противники стали реагировать на попадания по разному код снова мигрирует.
По примеру выше становиться заметно, что ответственность класса определяется не идеальными Платоновскими идеями, а тем как нам будет проще программировать.

Расширяем пример, у нас есть игровое поле с противниками на которое мы можем воздействовать предметами которые у нас в инвентаре.

![Unity_XYVO99NKSl](https://user-images.githubusercontent.com/86427892/174994456-9268af6a-5ca9-4125-b8e0-10c8ba13b003.png)

Нам необходимо добавить в игру предмет который меняет местами соседних противников. Где должен быть реализован функционал смены местами? Положение это инкапсулированное состояние противника, значит противники сами должны меняться местами и функционал должен быть в их классах? Или в классе предмета, ведь предметов может придется добавить много с разными способностями, а значит предмет при использовании должен получать ссылки на противников на которых воздействует и менять их местами? Или это метод игрового поля которое контролирует положение противников и знает кто с кем соседний, сами противники же не должны знать своих соседей, или наоборот?

Проблема того что мы вообще тратим время на эти вопросы и по ситуации перемещаем код из класса в класс исходит из того что мы воспринимаем одно общее состояние и функционал как несколько отдельных.
Суть в том что если функция затрагивает состояние нескольких объектов значит она не принадлежит ни одному из этих объектов, а является общей. Процесс происходящий над несколькими объектами не должен принадлежать кому-то из них. 
Тоже касается и состояния, поскольку в реальности оно может измениться из многих мест попытка это скрыть только усложнит общее понимание кода.

Исключением из вышесказанного являются библиотеки которые создаются чтобы использовать их между проектами.
В отдельные классы можно выделить наборы общих функций, к примеру для математических вычислений, физики, дебага или монетизации. С отделением состояния такого класса от состояния конкретной игры не возникает трудностей так как у него нет состояния. Все необходимые значения, в том числе постоянные можно указывать как параметры методов.

5.Решение.

Не использовать в разработке игр ООП. Не дробить код на маленькие простые части. Не рассредоточивать полезный код по десяткам классов. Не разделять части общего функционала и состояния на отдельные объекты. Не скрывать источники изменений состояния. Не прятать конечный функционал за интерфейсами и виртуальными методами.

Осознавать все объекты и функции игры как часть общего состояния и использовать их в общем контексте. К примеру, событие нажатия кнопки сразу обращается к состоянию персонажа и изменяет его, также самостоятельно вызывает сопутствующие методы дебага, аналитики, монетизации и тд.

В результате разработки проекта получатся один или несколько больших объектов и несколько очень больших функций. Создание крупной и сложной игры в одном файле или даже одной функции дает нам противоположную крайность. Наша цель четко определять исполняемый код максимально сохраняя читаемость. То есть, при необходимость дробить сложные и часто повторяющиеся операции на отдельные функции.

ООП программисту будет сложно воспринимать такой код. Одна функция будет производить сразу большой набор действий, иметь много строчек и возможно много отступов, что несомненно резко снижает читаемость такой функции. Также отсутствие объектов усложнит нахождение функционала относящегося к конкретному состоянию.
Однако понимание СИСТЕМЫ игры станет намного проще.

Да, такие функции производят много действий и затрагивают много состояний, но по факту абсолютно тоже самое происходит и в ООП, только происходящее скрыто от нас, разбросано среди классов. Ранее было сказано, что для полноценной разработки объекта нужно понимание контекста, вот он, весь на виду. 
Не нужно переключаться между классами и в голове обрабатывать сложные схемы куда в конечном счете нас заведет лестница из маленьких методов и маленьких классов с учетом полиморфных методов и переопределний функционала наследниками.

У нас получилась большая функция, которая возможно не помещается в экран, в ней много параметров, а возвращает она сложную структуру. Понять её не так просто как обычный маленький оопэшный метод, ограниченный рамками ответственности своего объекта. Однако, понимание этой функции равноценно пониманию связи десятка классов и их методов. В любом случае, для внесения изменений которые точно ничего не сломают в своей голове пришлось бы собирать весь набор действий которые следуют из начального метода. 
Такая сложность появилась не потому что мы неправильно создали функцию, она была всегда, мы вынуждены были держать её в голове или выражать в схемах, теперь в схемах нет необходимости, код исчерпывающе говорит сам за себя.

Для примера я попробовал реализовать игру которая бы была достаточно сложная в качестве примера разницы между функциональным и объектным программированием. Функциональный вариант полностью рабочий, в то время как вариант с ООП только намечены основные классы, после того как я закончил функциональный вариант и понял как много классов и как сложно устанавливать между ними взаимосвязи у меня отпало всякое желание доделывать ООП вариант, извините.

Касательно особенностей функционального стиля, который я использовал в проекте.
1.C# объектно ориентированный язык, поэтому создания классов не избежать. 
2.Для юнити требуется отдельная прослойка в виде MonoBehaviour, которые лежать в отдельной папке.
3.Я специально, по возможности, не использовал модификаторы доступа, чтобы подчеркнуть что в функциональном контексте они не имеют значения.
4.В отдельные методы выделяются только сложные для восприятия операции или операции которые применяются несколько раз.
5.Отдельные функции, которые применяются только в рамках другой функции определены в теле этой функции, чтобы подчеркнуть что они больше нигде не могут использоваться. Иногда это правило не соблюдается чтобы функции не были слишком огромны.

С предложениями и критикой -> https://t.me/Kustya1331
